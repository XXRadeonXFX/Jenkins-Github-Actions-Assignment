name: Flask CI/CD

on:
  push:
    branches: [main, staging]
  pull_request:
    branches: [main, staging]
  release:
    types: [created]

jobs:
  build-test:
    runs-on: ubuntu-latest

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🐍 Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: 📦 Cache dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: 📦 Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: 🧪 Run tests with cloud MongoDB
        run: |
          echo "Running tests with MongoDB cloud configuration..."
          python -m pytest test_app.py -v --tb=short --maxfail=5
        env:
          MONGO_URI: ${{ secrets.MONGO_URI }}

      - name: 🏗️ Build Docker image
        run: |
          echo "Building Docker image..."
          docker build -t student-management-app:${{ github.sha }} .
          echo "Docker image built successfully"

      - name: 💾 Save Docker image
        run: |
          docker save student-management-app:${{ github.sha }} | gzip > app.tar.gz

      - name: 📤 Upload Docker image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: app.tar.gz

  code-quality:
    runs-on: ubuntu-latest
    needs: build-test

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🐍 Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: 📦 Install code quality tools
        run: |
          python -m pip install --upgrade pip
          pip install flake8 black isort

      - name: 🧹 Check code formatting with Black
        run: black --check --diff . || echo "Code formatting check completed"

      - name: 📏 Check import sorting with isort
        run: isort --check-only --diff . || echo "Import sorting check completed"

      - name: 🔍 Lint with flake8
        run: flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || echo "Linting completed"

  security-scan:
    runs-on: ubuntu-latest
    needs: build-test

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🐍 Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: 🔒 Install security scanner
        run: |
          python -m pip install --upgrade pip
          pip install safety bandit

      - name: 🔍 Check for security vulnerabilities
        run: |
          safety check || echo "Security check completed"
          bandit -r . -f json || echo "Bandit security scan completed"

  deploy-staging:
    if: github.ref == 'refs/heads/staging' && github.event_name == 'push'
    runs-on: ubuntu-latest
    needs: [build-test, code-quality, security-scan]
    environment: staging

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 📥 Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: 🔑 Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.STAGING_SSH_KEY }}

      - name: 🔑 Configure SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Add host to known_hosts
          ssh-keyscan -H ${{ secrets.STAGING_HOST }} >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts
          
          # Create SSH config for easier connection
          cat > ~/.ssh/config << EOF
          Host staging
            HostName ${{ secrets.STAGING_HOST }}
            User ${{ secrets.STAGING_USER }}
            StrictHostKeyChecking no
            ConnectTimeout 30
            ServerAliveInterval 60
            ServerAliveCountMax 3
          EOF
          chmod 600 ~/.ssh/config

      - name: 🧪 Test SSH Connection
        run: |
          echo "Testing SSH connection to staging..."
          ssh staging "echo 'SSH connection successful'; whoami; pwd; docker --version || echo 'Docker not found'"

      - name: 🐛 Debug Environment
        run: |
          echo "=== Debug Information ==="
          echo "Host: ${{ secrets.STAGING_HOST }}"
          echo "User: ${{ secrets.STAGING_USER }}"
          echo "Current directory: $(pwd)"
          echo "Available files: $(ls -la)"
          echo "Docker image file size: $(du -h app.tar.gz)"

      - name: 📤 Copy files to staging
        run: |
          echo "Copying application files to staging server..."
          
          # Copy Docker image
          scp -v app.tar.gz staging:/tmp/app.tar.gz
          
          # Copy application files
          scp -v requirements.txt staging:/tmp/requirements.txt
          scp -v app.py staging:/tmp/app.py
          
          echo "Files copied successfully"

      - name: 🚀 Deploy to Staging
        run: |
          echo "Deploying to staging environment..."
          
          ssh staging << 'STAGING_EOF'
            set -e
            
            echo "=== Starting staging deployment ==="
            
            # Stop existing application
            echo "Stopping existing containers..."
            sudo pkill -f "python.*app.py" || true
            docker stop student-app-staging 2>/dev/null || true
            docker rm student-app-staging 2>/dev/null || true
            
            # Install Docker if not present
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              sudo usermod -aG docker $USER
              sudo systemctl start docker
              sudo systemctl enable docker
            fi
            
            # Load new Docker image
            echo "Loading Docker image..."
            cd /tmp
            
            if [ -f app.tar.gz ]; then
              gunzip -c app.tar.gz | docker load
              echo "Docker image loaded successfully"
            else
              echo "Error: app.tar.gz not found"
              exit 1
            fi
            
            # Run new container with MongoDB secret
            echo "Starting new container..."
            docker run -d \
              --name student-app-staging \
              --restart unless-stopped \
              -p 5000:5000 \
              -e MONGO_URI="${{ secrets.MONGO_URI }}" \
              student-management-app:${{ github.sha }}
            
            # Wait for application to start
            echo "Waiting for application to start..."
            sleep 15
            
            # Check if container is running
            if docker ps | grep student-app-staging; then
              echo "✅ Container is running"
            else
              echo "❌ Container failed to start"
              docker logs student-app-staging
              exit 1
            fi
            
            echo "✅ Staging deployment completed!"
          STAGING_EOF

      - name: 🧪 Run staging health check
        run: |
          echo "Running health check on staging..."
          max_attempts=10
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "Health check attempt $attempt/$max_attempts"
            
            if curl -f --connect-timeout 10 --retry 3 http://${{ secrets.STAGING_HOST }}:5000/health; then
              echo "✅ Staging health check passed!"
              break
            else
              echo "❌ Health check failed, retrying in 15 seconds..."
              sleep 15
              attempt=$((attempt + 1))
            fi
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "❌ Staging health check failed after $max_attempts attempts"
            echo "Checking container logs..."
            ssh staging "docker logs student-app-staging --tail 50"
            exit 1
          fi

      - name: 🧪 Run staging smoke tests
        run: |
          echo "Running smoke tests on staging..."
          
          # Test API endpoints
          echo "Testing /students endpoint..."
          if curl -f --connect-timeout 10 http://${{ secrets.STAGING_HOST }}:5000/students; then
            echo "✅ /students endpoint working"
          else
            echo "❌ /students endpoint failed"
            exit 1
          fi
          
          echo "Testing POST /students endpoint..."
          response=$(curl -f --connect-timeout 10 -X POST http://${{ secrets.STAGING_HOST }}:5000/students \
            -H "Content-Type: application/json" \
            -d '{"name": "Test User", "age": 25}')
          
          if [ $? -eq 0 ]; then
            echo "✅ POST /students endpoint working"
            echo "Response: $response"
          else
            echo "❌ POST /students endpoint failed"
            exit 1
          fi
          
          echo "✅ All smoke tests passed!"

      - name: 📢 Staging deployment notification
        run: |
          echo "✅ Staging deployment completed successfully!"
          echo "🌐 Staging URL: http://${{ secrets.STAGING_HOST }}:5000"
          echo "🏥 Health URL: http://${{ secrets.STAGING_HOST }}:5000/health"
          echo "🧪 Staging environment is ready for testing"

  deploy-production:
    if: github.event_name == 'release'
    runs-on: ubuntu-latest
    needs: [build-test, code-quality, security-scan]
    environment: production

    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 📥 Download Docker image
        uses: actions/download-artifact@v4
        with:
          name: docker-image

      - name: 🔑 Setup SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.PRODUCTION_SSH_KEY }}

      - name: 🔑 Configure SSH
        run: |
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh
          
          # Add host to known_hosts
          ssh-keyscan -H ${{ secrets.PRODUCTION_HOST }} >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts
          
          # Create SSH config for production
          cat > ~/.ssh/config << EOF
          Host production
            HostName ${{ secrets.PRODUCTION_HOST }}
            User ${{ secrets.PRODUCTION_USER }}
            StrictHostKeyChecking no
            ConnectTimeout 30
            ServerAliveInterval 60
            ServerAliveCountMax 3
          EOF
          chmod 600 ~/.ssh/config

      - name: 🧪 Test SSH Connection
        run: |
          echo "Testing SSH connection to production..."
          ssh production "echo 'SSH connection successful'; whoami; pwd; docker --version || echo 'Docker not found'"

      - name: 📤 Copy files to production
        run: |
          echo "Copying application files to production server..."
          
          # Copy Docker image
          scp -v app.tar.gz production:/tmp/app.tar.gz
          
          # Copy application files
          scp -v requirements.txt production:/tmp/requirements.txt
          scp -v app.py production:/tmp/app.py
          
          echo "Files copied successfully"

      - name: 🚀 Deploy to Production
        run: |
          echo "Deploying to production environment..."
          
          ssh production << 'PRODUCTION_EOF'
            set -e
            
            echo "=== Starting production deployment ==="
            
            # Create backup of current deployment
            if docker ps | grep student-app-production; then
              echo "Creating backup of current deployment..."
              docker tag student-management-app:current student-management-app:backup-$(date +%Y%m%d-%H%M%S) 2>/dev/null || true
            fi
            
            # Install Docker if not present
            if ! command -v docker &> /dev/null; then
              echo "Installing Docker..."
              curl -fsSL https://get.docker.com -o get-docker.sh
              sudo sh get-docker.sh
              sudo usermod -aG docker $USER
              sudo systemctl start docker
              sudo systemctl enable docker
            fi
            
            # Stop existing application gracefully
            echo "Stopping existing containers..."
            docker stop student-app-production 2>/dev/null || true
            docker rm student-app-production 2>/dev/null || true
            
            # Load new Docker image
            echo "Loading Docker image..."
            cd /tmp
            
            if [ -f app.tar.gz ]; then
              gunzip -c app.tar.gz | docker load
              echo "Docker image loaded successfully"
            else
              echo "Error: app.tar.gz not found"
              exit 1
            fi
            
            # Tag as current version
            docker tag student-management-app:${{ github.sha }} student-management-app:current
            
            # Run new container with MongoDB secret
            echo "Starting new container..."
            docker run -d \
              --name student-app-production \
              --restart unless-stopped \
              -p 80:5000 \
              -e MONGO_URI="${{ secrets.MONGO_URI }}" \
              student-management-app:current
            
            # Wait for application to start
            echo "Waiting for application to start..."
            sleep 20
            
            # Check if container is running
            if docker ps | grep student-app-production; then
              echo "✅ Container is running"
            else
              echo "❌ Container failed to start"
              docker logs student-app-production
              exit 1
            fi
            
            echo "✅ Production deployment completed!"
          PRODUCTION_EOF

      - name: 🧪 Run production health check
        run: |
          echo "Running health check on production..."
          max_attempts=15
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "Health check attempt $attempt/$max_attempts"
            
            if curl -f --connect-timeout 10 --retry 3 http://${{ secrets.PRODUCTION_HOST }}/health; then
              echo "✅ Production health check passed!"
              break
            else
              echo "❌ Health check failed, retrying in 20 seconds..."
              sleep 20
              attempt=$((attempt + 1))
            fi
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "❌ Production health check failed after $max_attempts attempts"
            echo "Rolling back deployment..."
            
            ssh production << 'ROLLBACK_EOF'
              echo "Rolling back to previous version..."
              docker stop student-app-production || true
              docker rm student-app-production || true
              
              # Find latest backup
              BACKUP_IMAGE=$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep backup- | head -n 1 | awk '{print $1}')
              
              if [ ! -z "$BACKUP_IMAGE" ]; then
                echo "Restoring backup: $BACKUP_IMAGE"
                docker run -d \
                  --name student-app-production \
                  --restart unless-stopped \
                  -p 80:5000 \
                  -e MONGO_URI="${{ secrets.MONGO_URI }}" \
                  $BACKUP_IMAGE
              else
                echo "No backup found, manual intervention required"
              fi
            ROLLBACK_EOF
            
            exit 1
          fi

      - name: 🧪 Run production smoke tests
        run: |
          echo "Running comprehensive smoke tests on production..."
          
          # Test core API endpoints
          echo "Testing /health endpoint..."
          if curl -f --connect-timeout 10 http://${{ secrets.PRODUCTION_HOST }}/health; then
            echo "✅ Health endpoint working"
          else
            echo "❌ Health endpoint failed"
            exit 1
          fi
          
          echo "Testing /students endpoint..."
          if curl -f --connect-timeout 10 http://${{ secrets.PRODUCTION_HOST }}/students; then
            echo "✅ Students endpoint working"
          else
            echo "❌ Students endpoint failed"
            exit 1
          fi
          
          echo "Testing POST /students endpoint..."
          response=$(curl -f --connect-timeout 10 -X POST http://${{ secrets.PRODUCTION_HOST }}/students \
            -H "Content-Type: application/json" \
            -d '{"name": "Production Test User", "age": 25}')
          
          if [ $? -eq 0 ]; then
            echo "✅ POST /students endpoint working"
            echo "Response: $response"
            
            # Extract student ID and test GET by ID
            student_id=$(echo "$response" | grep -o '"_id":"[^"]*"' | cut -d'"' -f4)
            if [ ! -z "$student_id" ]; then
              echo "Testing GET /students/$student_id endpoint..."
              if curl -f --connect-timeout 10 http://${{ secrets.PRODUCTION_HOST }}/students/$student_id; then
                echo "✅ GET by ID working"
              else
                echo "❌ GET by ID failed"
              fi
              
              echo "Testing DELETE /students/$student_id endpoint..."
              if curl -f --connect-timeout 10 -X DELETE http://${{ secrets.PRODUCTION_HOST }}/students/$student_id; then
                echo "✅ DELETE endpoint working"
              else
                echo "❌ DELETE endpoint failed"
              fi
            fi
          else
            echo "❌ POST /students endpoint failed"
            exit 1
          fi
          
          echo "✅ All production smoke tests passed!"

      - name: 📊 Production deployment notification
        run: |
          echo "🎉 Production deployment completed successfully!"
          echo "📦 Version: ${{ github.event.release.tag_name }}"
          echo "🌐 Production URL: http://${{ secrets.PRODUCTION_HOST }}"
          echo "🏥 Health URL: http://${{ secrets.PRODUCTION_HOST }}/health"
          echo "🚀 Production environment is live and healthy"

  cleanup:
    if: always()
    runs-on: ubuntu-latest
    needs: [build-test, code-quality, security-scan]

    steps:
      - name: 🧹 Cleanup test data
        run: |
          echo "Cleaning up any test data from cloud MongoDB..."
          # Add cleanup script if needed
          echo "Test cleanup completed"
        env:
          MONGO_URI: ${{ secrets.MONGO_URI }}